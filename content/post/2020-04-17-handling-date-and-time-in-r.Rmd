---
title: "A Comprehensive Introduction to Handling Date & Time in R"
author: Aravind Hebbali
twitterImg: /img/handling-date-and-time-in-r.png
description: "Learn to handle date & time in R"
date: '2020-04-17'
slug: handling-date-and-time-in-r
categories:
  - data-wrangling
tags:
  - lubridate
  - datetime
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r pkg_load, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
library(kableExtra)
library(magrittr)
library(lubridate)
library(rversions)
library(readr)
library(dplyr)
```

```{r cover_image, echo=FALSE, fig.align="center", out.width="80%"}
knitr::include_graphics("/img/handling-date-and-time-in-r.png")
```

In this tutorial, we will learn to handle date & time in R. We will start off by learning how
to **get current date & time** before moving on to understand **how R handles date/time internally**
and the different classes such as `Date` & `POSIXct/lt`. We will spend some time 
exploring **time zones, daylight savings and ISO 8001 standard** for representing date/time.
We will look at all the **weird formats in which date/time come in real world** and learn to
**parse them using conversion specifications**. After this, we will also **learn how to handle date/time
columns while reading external data into R**. We will learn to **extract and update different date/time 
components** such as year, month, day, hour, minute etc., **create sequence of dates** in different ways 
and explore intervals, durations and period. We will end the tutorial by learning how to **round/rollback 
dates**. Throughout the tutorial, we will also **work through a case study** to better understand the 
concepts we learn. Happy learning!

## Table of Contents

- [Resources](#resources)
- [Introduction](#intro)
- [Case Study](#casestudy)
- [Date & Time Classes](#classes)
- [Date Arithmetic](#arithmetic)
- [Timezones & Daylight Savings](#timezones)
- [Date & Time Formats](#formats)
- [Parse/Read Date & Time](#parse)
- [Date & Time Components](#components)
- [Create, Update & Verify](#createupdate)
- [Intervals, Durations & Period](#intervals)
- [Round & Rollback](#others)
- [References](#references)

## Resources {#resources}

Below are the links to all the resources related to this tutorial:

- <a href="https://slides.rsquaredacademy.com/handling-date-and-time-in-r.pdf" target="_blank">Slides</a>
- <a href="https://github.com/rsquaredacademy-education/online-courses/" target="_blank">Code & Data</a>
- <a href="https://rstudio.cloud/project/1072419" target="_blank">RStudio Cloud Project</a>
- <a href="https://wrangle-r.rsquaredacademy.com/lubridate.html" target="_blank">ebook</a>

<p align="center">
<a href="https://rsquared-academy.thinkific.com/courses/handling-date-and-time-in-R" target="_blank"><img src="/img/lubirdate-blog-course-ad.png" width="100%" alt="new courses ad" style="text-decoration: none;"></a>
</p>


## Introduction {#intro}

```{r cline_youtube_intro, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "322IcnZiYx4")
```

### Date

Let us begin by looking at the current date and time.  `Sys.Date()` and `today()`  will return the current date.

```{r sys_date}
Sys.Date()
lubridate::today()
```

### Time

`Sys.time()` and `now()` return the date, time and the timezone. In `now()`, we can specify the timezone using the `tzone` argument.

```{r sys_time}
Sys.time()
lubridate::now()
lubridate::now(tzone = "UTC")
```

### AM or PM?

`am()` and `pm()` allow us to check whether date/time occur in the `AM` or `PM`? They return a logical value i.e. `TRUE` or `FALSE`

```{r lub_am}
lubridate::am(now())
lubridate::pm(now())
```

### Leap Year

We can also check if the current year is a leap year using `leap_year()`. 

```{r leap_year}
Sys.Date()
lubridate::leap_year(Sys.Date())
```

### Summary

```{r table_current_date_time, echo=FALSE}
cname   <- c("`Sys.Date()`", "`lubridate::today()`", "`Sys.time()`",
             "`lubridate::now()`", "`lubridate::am()`", "`lubridate::pm()`",
             "`lubridate::leap_year()`")
descrip <- c("Current Date", "Current Date", "Current Time", "Current Time",
             "Whether time occurs in am?", "Whether time occurs in pm?",
             "Check if the year is a leap year?")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

### Your Turn

- get current date
- get current time
- check whether the time occurs in am or pm?
- check whether the following years were leap years
    - 2018
    - 2016

## Case Study {#casestudy}

Throughout the tutorial, we will work on a case study related to transactions of an imaginary trading company. The data set includes information about invoice and payment dates.

### Data

```{r import, eval=FALSE}
transact <- readr::read_csv('https://raw.githubusercontent.com/rsquaredacademy/datasets/master/transact.csv')
```

```{r show, echo=FALSE, eval=TRUE, message=FALSE}
transact <- readr::read_csv('https://raw.githubusercontent.com/rsquaredacademy/datasets/master/transact.csv')
transact
```

We will explore more about reading data sets with date/time columns after learning how to 
parse date/time. We have shared the code for reading the data sets used in the practice
questions both in the Learning Management System as well as in our GitHub repo.

### Data Dictionary

The data set has 3 columns. All the dates are in the format (yyyy-mm-dd).

```{r table_data_dict, echo=FALSE}
cname   <- c("Invoice", "Due", "Payment")
descrip <- c("Invoice Date", "Due Date", "Payment Date")
data.frame(Column = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

In the case study, we will try to answer a few questions we have about the `transact` data.

- extract date, month and year from Due
- compute the number of days to settle invoice
- compute days over due
- check if due year is a leap year
- check when due day in february is 29, whether it is a leap year
- how many invoices were settled within due date
- how many invoices are due in each quarter

## Date & Time Classes {#classes}

```{r cline_youtube_classes, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "IEX49t8sSgw")
```

In this section, we will look at two things. First, how to create date/time
data in R, and second, how to convert other data types to date/time. Let us 
begin by creating the release date of R 3.6.2.

```{r date_manual}
release_date <- 2019-12-12
release_date
```

Okay! Why do we see `1995` when we call the date? What is happening here? Let us 
quickly check the data type of `release_date`.

```{r date_type}
class(release_date)
```

The data type is `numeric` i.e. R has subtracted `12` twice from `2019` to 
return `1995`. Clearly, the above method is not the right way to store 
date/time. Let us see if we can get some hints from the built-in R functions we 
used in the previous section. If you observe the output, all of them returned 
date/time wrapped in quotes. Hmmm... let us wrap our date in quotes and see what 
happens.

```{r date_wrap}
release_date <- "2019-12-12"
release_date
```

Alright, now R does not do any arithmetic and returns the date as we specified. 
Great! Is this the right format to store date/time then? No. Why? What is the problem 
if date/time is saved as character/string? The problem is the nature or type of 
operations done on date/time are different when compared to string/character, 
number or logical values.

- how do we add/subtract dates?
- how do we extract components such as year, month, day etc.

To answer the above questions, we will first check the data type of `Sys.Date()` 
and `now()`.

```{r check_date_type}
class(Sys.Date())
class(lubridate::now())
class(release_date)
```

As you can see from the above output, there are 3 different classes for storing
date/time in R 

- `Date`
- `POSIXct`
- `POSIXlt`

Let us explore each of the above classes one by one.

### Date

#### Introduction

The `Date` class represents calendar dates. Let us go back to `Sys.Date()`. If 
you check the class of `Sys.Date()`, it is `Date`. Internally, this date is a 
number i.e. an integer. The `unclass()` function will show how dates are stored 
internally.

```{r unclass_sys_date}
Sys.Date()
unclass(Sys.Date())
```

What does this integer represent? Why has R stored the date as an integer? 
In R, dates are represented as the number of days since `1970-01-01`. All the dates in R are 
internally stored in this way. Before we explore this concept further, let us 
learn to create `Date` objects in R. We will continue to use the release date
of R 3.6.2, `2019-12-12`.

Until now, we have stored the above date as character/string but now we will use 
`as.Date()` to save it as a `Date` object. `as.Date()` is the easiest and 
simplest way to create dates in R.

```{r release_as_date}
release_date <- as.Date("2019-12-12")
release_date
```

The `as_date()` function from the lubridate package is similar to `as.Date()`.

```{r release_date_lubridate}
release_date <- lubridate::as_date("2019-12-12")
release_date
```

If you look at the difference between `release_date` and `1970-01-01`, it will 
be the same as `unclass(release_date)`.

```{r release_date_unclass}
release_date - as.Date("1970-01-01")
unclass(release_date)
```

Let us come back to `1970-01-01` i.e. the origin for dates in R. 

```{r origin}
lubridate::origin
```

From the previous examples, we know that dates are internally stored as number
of days since `1970-01-01`. How about dates older than the origin? How are they
stored? Let us look at that briefly.

```{r older_than_origin}
unclass(as.Date("1963-08-28"))
```

Dates older than the origin are stored as negative integers. For those who are 
not aware, Martin Luther King, Jr. delivered his famous **I Have a Dream** 
speech on `1963-08-28`. Let us move on and learn how to convert numbers into 
dates.

#### Convert Numeric

The `as.Date()` function can be used to convert any of the following to a `Date` 
object

- character/string
- number
- factor (categorical/qualitative)

We have explored how to convert strings to date. How about converting numbers to 
date? Sure, we can create date from numbers by specifying the origin and number 
of days since it. 

```{r release_date_origin}
as.Date(18242, origin = "1970-01-01")
```

The origin can be changed to another date (while changing the number as well.)

```{r release_date_diff_origin}
as.Date(7285, origin = "2000-01-01")
```

### ISO 8601 

```{r img1lub, fig.align='center', echo=FALSE, out.width="70%"}
knitr::include_graphics('/img/iso.png')
```

If you have carefully observed, the format in which we have been specifying the 
dates as well as of those returned by functions such as `Sys.Date()` or 
`Sys.time()` is the same i.e. `YYYY-MM-DD`. It includes

- the year including the century
- the month
- the date

The month and date separated by `-`. This default format used in R is the ISO 
8601 standard for date/time. ISO 8601 is the internationally accepted way to 
represent dates and times and uses the 24 hour clock system. Let us create the 
release date using another function `ISOdate()`.

```{r iso_date}
ISOdate(year  = 2019,
        month = 12,
        day   = 12,
        hour  = 8,
        min   = 5, 
        sec   = 3,
        tz    = "UTC")
```

We will look at all the different weird ways in which date/time are specified in 
the real world in the [Date & Time Formats] section. For the time being, let us 
continue exploring date/time classes in R. The next class we are going to look 
at is `POSIXct/POSIXlt`.

### POSIX

You might be wondering what is this POSIX thing? POSIX stands for **P**ortable 
**O**perating **S**ystem **I**nterface. It is a family of standards specified for 
maintaining compatibility between different operating systems. Before we 
learn to create POSIX objects, let us look at `now()` from lubridate.

```{r now_class}
class(lubridate::now())
```

`now()` returns current date/time as a POSIXct object. Let us look at its
internal representation using `unclass()`

```{r now_unclass}
unclass(lubridate::now())
```

The output you see is the number of seconds since January 1, 1970.

#### POSIXct

`POSIXct` represents the number of seconds since the beginning of 1970 (UTC) and 
`ct` stands for calendar time.  To store date/time as `POSIXct` objects, use 
`as.POSIXct()`. Let us now store the release date of R 3.6.2 as `POSIXct` as shown 
below

```{r release_date_posixct}
release_date <- as.POSIXct("2019-12-12 08:05:03")
class(release_date)
unclass(release_date) 
```

#### POSIXlt

`POSIXlt` represents the following information in a list

- seconds
- minutes
- hour
- day of the month
- month
- year
- day of week
- day of year
- daylight saving time flag
- time zone
- offset in seconds from GMT

The `lt` in `POSIXlt` stands for local time. Use `as.POSIXlt()` to store 
date/time as `POSIXlt` objects. Let us store the release date as a `POSIXlt` 
object as shown below

```{r release_date_posixlt_1}
release_date <- as.POSIXlt("2019-12-12 08:05:03")
release_date
```

As we said earlier, `POSIXlt` stores date/time components in a list and these 
can be extracted. Let us look at the date/time components returned by `POSIXlt` 
using `unclass()`.

```{r release_date_posixlt_2}
release_date <- as.POSIXlt("2019-12-12 08:05:03")
unclass(release_date)
```

Use `unlist()` if you want the components returned as a `vector`.

```{r release_date_posixlt_3}
release_date <- as.POSIXlt("2019-12-12 08:05:03")
unlist(release_date)
```

To extract specific components, use `$`. 

```{r release_date_posixlt_4}
release_date <- as.POSIXlt("2019-12-12 08:05:03")
release_date$hour
release_date$mon
release_date$zone
```

Now, let us look at the components returned by `POSIXlt`. Some of them are 
intuitive

```{r table_posixlt_1, echo=FALSE}
cname   <- c("`sec`", "`min`", "`hour`", "`mon`", "`zone`", "`wday`", "`mday`", "`year`", "`yday`", "`isdst`", "`gmtoff`")
descrip <- c("Second", "Minute", "Hour of the day", "Month of the year (0-11",
             "Timezone", "Day of week", "Day of month","Years since 1900", 
             "Day of year", "Daylight saving flag", 
             "Offset is seconds from GMT")
data.frame(Component = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Great! We will end this section with a few tips/suggestions on when to use 
`Date` or `POSIXct/POSIXlt`. 

- use `Date` when there is no time component
- use `POSIX` when dealing with time and timezones
- use `POSIXlt` when you want to access/extract the different components

### Your Turn

R 1.0.0 was released on `2000-02-29 08:55:23 UTC`. Save it as 

- `Date` using character 
- `Date` using origin and number
- `POSIXct`
- `POSIXlt` and extract 
    - month day
    - day of year
    - month
    - zone
- ISODate

## Date Arithmetic {#arithmetic}

```{r cline_youtube_arithmetic, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "iNzv8Ezpjw0")
```

Time to do some arithmetic with the dates. Let us calculate the length of a 
course you have enrolled for (Become a Rock Star Data Scientist in 10 Days) by subtracting the course start date from the course end date.

<br>

```{r img2lub, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/course_duration.png")
```

<br>

```{r lub19, collapse = TRUE}
course_start    <- as_date('2017-04-12')
course_end      <- as_date('2017-04-21')
course_duration <- course_end - course_start
course_duration
```

### Shift Date

Time to shift the course dates. We can shift a date by days, weeks or months. Let us shift the course start date by:

- 2 days
- 3 weeks
- 1 year

<br>

```{r img3lub, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/shift_dates.png")
```

<br>

```{r lab40, collapse = TRUE}
course_start + days(2)
course_start + weeks(3)
course_start + years(1)
```

### Case Study

#### Compute days to settle invoice

Let us estimate the number of days to settle the invoice by subtracting the
date of invoice from the date of payment.

```{r lub3}
transact %>%
  mutate(
    days_to_pay = Payment - Invoice
  )
```

#### Compute days over due

How many of the invoices were settled post the due date? We can find this by:

- subtracting the due date from the payment date
- counting the number of rows where delay > 0 

```{r lub4}
transact %>%
  mutate(
    delay = Payment - Due
  ) %>%
  filter(delay > 0) %>% 
  count(delay)
```

### Your Turn

- compute the length of a vacation which begins on `2020-04-19` and ends on `2020-04-25`
- recompute the length of the vacation after shifting the vacation start and end date by `10` days and `2` weeks
- compute the days to settle invoice and days overdue from the `receivables.csv` data set
- compute the length of employment (only for those employees who have been terminated) from the `hr-data.csv` data set (use date of hire and termination)

## Time Zones & Daylight Savings {#timezones}

```{r cline_youtube_timezones, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "Sz-Zf0s9Ubg")
```

### Introduction

```{r img_timezones, fig.align='center', out.width="70%", echo=FALSE}
knitr::include_graphics('/img/lub_timezones.jpg')
```

In the previous section, `POSIXlt` stored date/time components as a list. Among 
the different components it returned were

- `gmtoff`
- `zone`

`gmtoff` is offset in seconds from GMT i.e. difference in hours and minutes from 
UTC. Wait.. What do UTC and GMT stand for?

- Coordinated Universal Time (UTC)
- Greenwich Meridian Time (GMT)

Since we are talking about UTC, GMT etc., let us spend a little time on 
understanding the basics of time zones and daylight savings.

### Time Zones

Timezones exist because different parts of the Earth receive sun light at 
different times. If there was a single timezone, noon or morning would mean 
different things in different parts of the world. The timezones are based on 
Earth's rotation. The Earth moves ~15 degrees every 60 minutes i.e. 360 degrees 
in 24 hours. The planet is divided into 24 timezones, each 15 degrees of 
longitude width. 

Now, you have heard of Greenwich Meridian Time (GMT) right? We just saw GMT off 
set in `POSIXlt` and you would have come across it in other time formats as 
well. For example, India timezone is given as GMT +5:30. Let us explore GMT in a 
little more detail. Greenwich is a suburb of London and the time at Greenwich 
is **G**reenwich **M**ean **T**ime. As you move West from Greenwich, every 15 
degree section is one hour earlier than GMT and every 15 degree section to the 
East is an hour later. 

Alright! What is **UTC** then? **C**oordinated **U**niversal **T**ime (UTC) , 
on the other hand, is the time standard commonly used across the world. Even 
though they share the same current time, **GMT** is a **timezone** while 
**UTC** is a **time standard**.

So how do we check the timezone in R? When you run `Sys.timezone()`, you should 
be able to see the timezone you are in. 

```{r sys_time_zones}
Sys.timezone()
```

If you do not see the timezone, use `Sys.getenv()` to get the value of the 
**TZ** environment variable.

```{r get_time_zone}
Sys.getenv("TZ")
```

If nothing is returned, it means we have to set the timezone. Use `Sys.setenv()` 
to set the timezone as shown below. The author resides in India and hence the 
timezone is set to `Asia/Calcutta`. You need to set the timezone in which you 
reside or work.

```{r set_time_zone}
Sys.setenv(TZ = "Asia/Calcutta")
```

Another way to get the timezone is through `tz()` from the lubridate package.

```{r tz_release_date}
lubridate::tz(Sys.time())
```

If you want to view the time in a different timezone, use `with_tz()`. Let us 
look at the current time in **UTC** instead of **Indian Standard Time**.

```{r with_tz}
lubridate::with_tz(Sys.time(), "UTC")
```

### Daylight Savings

```{r img_daylight, fig.align='center', out.width="70%", echo=FALSE}
knitr::include_graphics('/img/lub_daylight_savings.png')
```

Daylight savings also known as 

- daylight saving time
- daylight savings time
- daylight time
- summer time

is the practice of advancing clocks during summer months so that darkness falls 
later each day according to the clock. In other words

- advance clock by one hour in spring (spring forward)
- retard clocks by one hour in autumn (fall back)

In R, the `dst()` function is an indicator for daylight savings. It returns 
`TRUE` if daylight saving is in force, `FALSE` if not and `NA` if unknown.

```{r dst}
Sys.Date()
dst(Sys.Date()) 
```

### Your Turn

- check the timezone you live in
- check if daylight savings in on
- check the current time in **UTC** or a different time zone 

## Date & Time Formats {#formats}

```{r cline_youtube_formats, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "BdHTrItYKJw")
```

After the timezones and daylight savings detour, let us get back on path and 
explore another important aspect, date & time formats. Although it is a good 
practice to adher to ISO 8601 format, not all date/time data will comply with 
it. In real world, date/time data may come in all types of weird formats. Below
is a sample

```{r table_formats_sample, echo=FALSE}
cname   <- c("December 12, 2019", "12th Dec, 2019", "Dec 12th, 19", "12-Dec-19",
             "2019 December", "12.12.19") 
data.frame(Format = cname) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

When the data is not in the default ISO 8601 format, we need to explicitly 
specify the format in R. We do this using conversion specifications. A 
conversion specification is introduced by %, usually followed by a single 
letter or O or E and then a single letter. 

### Conversion Specifications

```{r table_formats_1, echo=FALSE}
cname   <- c("`%d`", "`%m`", "`%b`", "`%B`", "`%y`", "`%Y`", "%H", "%M", "%S")
descrip <- c("Day of the month (decimal number)",
             "Month (decimal number)",
             "Month (abbreviated)",
             "Month (full name)",
             "Year (2 digit)",
             "Year (4 digit)",
             "Hour",
             "Minute",
             "Second")
example <- c(12, 12, "Dec", "December", 19, 2019, 08, 05, 03)
data.frame(Specification = cname, Description = descrip, Example = example) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Time to work through a few examples. Let us say you are dealing with dates in 
the format `19/12/12`. In this format, the year comes first followed by month 
and the date; each separated by a slash (`/`). The year consists of only 2 
digits i.e. it does not include the century. Let us now map each component of 
the date to the conversion specification table shown at the beginning.

```{r table_formats_ex_1, echo=FALSE}
cname   <- c("19", "12", "12")
descrip <- c("`%y`", "`%m`", "`%d`")
data.frame(Date = cname, Specification = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Using the format argument, we will specify the conversion specification as a character vector
i.e. enclosed in quotes.

```{r format_examples_1}
as.Date("19/12/12", format = "%y/%m/%d")
```

Another way in which the release data can be written is `2019-Dec-12`. We still 
have the year followed by the month and the date but there are a few changes 
here:

- the components are separated by a `-` instead of `/`
- year has 4 digits i.e. includes the century
- the month is specified using abbreviation instead of digits

Let us map the components to the format table:

```{r table_formats_ex_2, echo=FALSE}
cname   <- c("2019", "Dec", "12")
descrip <- c("`%Y`", "`%b`", "`%d`")
data.frame(Date = cname, Specification = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Let us specify the format for the date using the above mapping.

```{r format_examples_2}
as.Date("2019-Dec-12", format = "%Y-%b-%d")
```

In both the above examples, we have not dealt with time components. Let us 
include the release time of R 3.6.2 in the next one i.e. 
`19/12/12 08:05:03`.

```{r table_formats_ex_3, echo=FALSE}
cname   <- c("19", "12", "12", "08", "05", "03")
descrip <- c("`%y`", "`%m`", "`%d`", "`%H`", "`%M`", "`%S`")
data.frame(Date = cname, Specification = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

Since we are dealing with time, we will use `as.POSIXct()` instead of 
`as.Date()`.

```{r format_examples_3}
as.POSIXct("19/12/12 08:05:03", tz = "UTC", format = "%y/%m/%d %H:%M:%S")
```

In the below table, we look at some of the most widely used conversion 
specifications. You can learn more about these specifications by running 
`?strptime` or `help(strptime)`.

```{r table_formats_2, echo=FALSE}
cname   <- c("`%a`", "`%A`", "`%C`", "`%D`", "`%e`", "`%F`", "`%h`", "`%I`", "`%j`",
             "`%R`", "`%t`", "`%T`", "`%u`", "`%U`", "`%V`", "`%w`", "`%W`")
descrip <- c("Abbreviated weekday",
             "Full weekday",
             "Century (00-99)",
             "Same as `%m/%d/%y`",
             "Day of month [1 - 31]",
             "Same as `%Y-%m-%d`",
             "Same as `%b`",
             "Hours as decimal [01 - 12]",
             "Day of year [001 - 366]",
             "Same as `%H:%M`",
             "Tab",
             "Same as `%H:%M:%S`",
             "Weekday [1 - 7](Monday is 1)",
             "Week of year [00 - 53]",
             "Week of year [01 - 53]",
             "Weekday [0 - 6](sunday is 0)",
             "Week of year [00 - 53]")
data.frame(Specification = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

We have included a lot of practice questions for you to explore the different 
date/time formats. The solutions are available in the Learning Management System 
as well as in our GitHub repo. Try them and let us know if you have any doubts.

### Guess Format

`guess_formats()` from lubridate is a very useful function. It will guess the 
date/time format if you specify the order in which year, month, date, hour, 
minute and second appear.

```{r guess_formats}
release_date_formats <- c("December 12th 2019",
                        "Dec 12th 19",
                        "dec 12 2019")

guess_formats(release_date_formats, 
              orders = "mdy", 
              print_matches = TRUE)
```

### Your Turn

Below, we have specified `July 5th, 2019` in different ways. Create the date using `as.Date()` while specifying the correct format for each of them.

- `05.07.19`
- `5-July 2019`
- `July 5th, 2019`
- `July 05, 2019`
- `2019-July- 05`
- `05/07/2019`
- `07/05/2019`
- `7/5/2019`
- `07/5/19`
- `2019-07-05`

## Parse Date & Time {#parse}

```{r cline_youtube_parse, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "FqWb-OS6wu4")
```

While creating date-time objects, we specified different formats using the 
conversion specification but most often you will not create date/time and
instead deal with data that comes your way from a database or API or 
colleague/collaborator. In such cases, we need to be able to parse date/time 
from the data provided to us. In this section, we will focus on parsing 
date/time from character data. Both base R and the lubridate package offer 
functions to parse date and time and we will explore a few of them in this 
section. We will initially use functions from base R and later on explore those
from lubridate which will give us an opportunity to compare and contrast. It 
will also allow us to choose the functions based on the data we are dealing 
with.

`strptime()` will convert character data to `POSIXlt`. You will use this when
converting from character data to date/time. On the other hand, if you want to
convert date/time to character data, use any of the following:

- `strftime()`
- `format()`
- `as.character()`

The above functions will convert `POSIXct/POSIXlt` to character. Let us start
with a simple example. The data we have been supplied has date/time as 
character data and in the format `YYYYMMDD` i.e. nothing separates the year, 
month and date from each other. We will use `strptime()` to convert this to an
object of class `POSIXlt`.

```{r strptime_1}
rel_date <- strptime("20191212", format = "%Y%m%d")
class(rel_date)
```

If you have a basic knowledge of conversion specifications, you can use 
`strptime()` to convert character data to `POSIXlt`. Let us quickly explore the
functions to convert date/time to character data before moving on to the 
functions from lubridate.

```{r}
rel_date_strf <- strftime(rel_date)
class(rel_date_strf)

rel_date_format <- format(rel_date)
class(rel_date_format)

rel_date_char <- as.character(rel_date)
class(rel_date_char)
```

As you can see, all the 3 functions converted date/time to character. Time to 
move on and explore the lubridate package. We will start with an example in 
which the release date is formatted in 3 different ways but they have one thing 
in common i.e. the order in which the components appear. In all the 3 formats, 
the year is followed by the month and then the date.

To parse the release date, we will use `parse_date_time()` from lubridate which 
parses the input into `POSIXct` objects.

```{r parse_date_time}
release_date <- c("19-12-12", "20191212", "19-12 12")
parse_date_time(release_date, "ymd")
parse_date_time(release_date, "y m d")
parse_date_time(release_date, "%y%m%d")
```

Try to use `strptime()` in the above example and see what happens. Now, let us 
look at another data set. 

```{r parse_date_time_multiple}
release_date <- c("19-07-05", "2019-07-05", "05-07-2019")
```

What happens in the below case? The same date appears in multiple formats. How 
do we parse them? `parse_date_time()` allows us to specify mutiple date-time 
formats. Let us first map the dates to their formats.

```{r table_formats_pdt, echo=FALSE}
cname   <- c("19-07-05", "2019-07-05", "05-07-2019")
descrip <- c("`ymd`", "`ymd`", "`dmy`")
data.frame(Date = cname, Specification = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

The above specifications can be supplied as a character vector.

```{r parse_date_2}
parse_date_time(release_date, c("ymd", "ymd", "dmy"))
```

Great! We have used both `strptime()` and `parse_date_time()` now. Can you tell 
what differentiates `parse_date_time()` when compared to `strptime()`? We 
summarize it in the points below:

- no need to include `%` prefix or separator
- specify several date/time formats

There are other helper functions that can be used to 

- parse dates with only year, month, day components
- parse dates with year, month, day, hour, minute, seconds components
- parse dates with only hour, minute, second components

and are explored in the below examples.

```{r parse_ymd}
# year/month/date
ymd("2019-12-12")

# year/month/date
ymd("19/12/12")

# date/month/year
dmy(121219)

# year/month/date/hour/minute/second
ymd_hms(191212080503)

# hour/minute/second
hms("8, 5, 3")

# hour/minute/second
hms("08:05:03")

# minute/second
ms("5,3")

# hour/minute
hm("8, 5")
```

Note, in a couple of cases where the components are not separated by `/`, `-` or 
space, we have not enclosed the values in quotes. 

### Your Turn

Below, we have specified `July 5th, 2019` in different ways. Parse the dates using `strptime()` or `parse_date_time()` or any other helper function.

- `July-05-19`
- `JUL-05-19`
- `05.07.19`
- `5-July 2019`
- `July 5th, 2019`
- `July 05, 2019`
- `2019-July- 05`
- `05/07/2019`
- `07/05/2019`
- `7/5/2019`
- `07/5/19`
- `2019-07-05`

## Date & Time Components {#components}

```{r cline_youtube_components, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "88iUo0Z06ZI")
```

In the second section, we discussed the downside of saving date/time as 
character/string in R. One of the points we discussed was that we can't extract 
components such as year, month, day etc. In this section, we will learn to 
extract date/time components such as

- year
- month
- date
- week
- day
- quarter
- semester
- hour
- minute
- second
- timezone

```{r img_day_week_month, fig.align='center', echo=FALSE, out.width="80%"}
knitr::include_graphics('/img/day_week_month.png')
```

The below table outlines the functions we will explore in the first part of this
section. 

```{r table_components_1, echo=FALSE}
cname   <- c("`year()`", "`month()`", "`month(label = TRUE)`", 
             "`month(abbr = FALSE)`", "`months()`", "`week()`")
descrip <- c("Get year", "Get month (number)", "Get month (abbreviated name)", 
             "Get month (full name)", "Get month", "Get week")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```


### Year

```{r year}
release_date <- ymd_hms("2019-12-12 08:05:03")
year(release_date) 
```

### Month

`month()` will return the month as a number i.e. `12` for December. 

```{r month_1}
month(release_date)
```

Instead, if you want the name of the month , use the `label` argument and set it 
to `TRUE`. Now it returns `Dec` instead of `12`.

```{r month_2}
month(release_date, label = TRUE)
```

But this is the abbreviated name and not the full name. How do we get the full 
name of the month? Set the `abbr` argument to `FALSE`. 

```{r month_3}
month(release_date, label = TRUE, abbr  = FALSE)
```

Ah! now we can see the full name of the month. `months()` from base R will 
return the full name of the month by default. If you want the abbreviated name, 
use the `abbreviate` argument and set it to `TRUE`.

```{r month_4}
months(release_date)
```

### Week

`week()` returns the number of complete 7 day periods between the date and 1st 
January plus one. 

```{r week}
week(release_date)
```

### Day

Use `day()` to extract the date component. There are other variations such as

```{r table_components_2, echo=FALSE}
cname   <- c("`day`", "`mday()`", "`wday()`", "`qday()`", "`yday()`", 
             "`weekdays()`", "`days_in_month()`")
descrip <- c("Get day", "Day of the month", "Day of the week", "Day of quarter",
             "Day of year", "Day of week", "Days in the month")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

```{r day_1}
day(release_date)
mday(release_date)                 
qday(release_date)                 
yday(release_date)                 
```

`wday` can return

- a number
- abbreviation of the weekday
- full name of the weekday

```{r day_2}
wday(release_date)  
wday(release_date, label = TRUE)
wday(release_date, label = TRUE, abbr  = FALSE)  
```

`weekdays()` from base R also returns the day of the week (the name and not 
the number). If you want the abbreviated name, use the `abbreviate` argument.

```{r day_3}
weekdays(release_date)
weekdays(release_date, abbreviate = TRUE)
```

### Days in Month

If you want to know the number of days in the month, use `days_in_month()`. 
In our example, the month is December and it has 31 days.

```{r days_in_month}
days_in_month(release_date)
```

### Hour, Minute & Seconds

```{r table_components_3, echo=FALSE}
cname   <- c("`hour()`", "`minute()`", "`second()`", "`seconds()`")
descrip <- c("Get hour", "Get minute", "Get second", 
             "Number of seconds since `1970-01-01`")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

So far we have been looking at date components. Now, let us look at time 
components.

```{r hour_min_sec_tz}
hour(release_date)
minute(release_date)
second(release_date)
```

`seconds()` returns the number of seconds since `1970-01-01`.

```{r hour_min_seconds}
seconds(release_date)
```

### Quarter & Semester

```{r img_quarter_semester, fig.align='center', echo=FALSE, out.width="80%"}
knitr::include_graphics('/img/quarter_semester.png')
```

`quarter()` will return the quarter from the date. December is in the 4th 
quarter and hence it returns 4. 

```{r quarter_1}
quarter(release_date)
```

If you want the year along with the quarter, set the `with_year` argument to 
`TRUE`.

```{r quarter_2}
quarter(release_date, with_year = TRUE)
```

In India, the fiscal starts in April and December falls in the 3rd quarter. How 
can we accommodate this change? The `fiscal_start` argument allows us to set the 
month in which the fiscal begins. We will set it to 4 for April. Now it returns 
3 instead of 4.

```{r quarter_3}
quarter(release_date, fiscal_start = 4)    
```

`quarters()` from base R also returns the quarter.

```{r quarter_4}
quarters(release_date)
```

```{r table_components_4, echo=FALSE}
cname   <- c("`quarter()`", "`quarter(with_year = TRUE)`", 
             "`quarter(fiscal_start = 4)`", "`quarters()`", "`semester()`")
descrip <- c("Get quarter", "Quarter with year", "Fiscal starts in April",
             "Get quarter", "Get semester")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

### Case Study

#### Extract Date, Month & Year from Due Date

Let us now extract the date, month and year from the `Due` column.

```{r lub2}
transact %>%
  mutate(
    due_day   = day(Due),
    due_month = month(Due),
    due_year  = year(Due)
  )
```

#### Data Sanitization

Let us do some data sanitization. If the due day happens to be February 29, 
let us ensure that the due year is a leap year. Below are the steps to check 
if the due year is a leap year:

- we will extract the following from the due date:
    - day
    - month
    - year
- we will then create a new column `is_leap` which will have be set to `TRUE` if 
the year is a leap year else it will be set to `FALSE` 
- filter all the payments due on 29th Feb
- select the following columns:
    - `Due`
    - `is_leap`

```{r lub6}
transact %>%
  mutate(
    due_day   = day(Due),
    due_month = month(Due),
    due_year  = year(Due),
    is_leap   = leap_year(due_year)
  ) %>%
  filter(due_month == 2 & due_day == 29) %>%
  select(Due, is_leap) 
```

#### Invoices Distribution by Quarter

Let us count the invoices due for each quarter.

```{r lub8}
transact %>%
  mutate(
    quarter_due = quarter(Due)
  ) %>%
  count(quarter_due)
```

### Your Turn

Get the R release dates using `r_versions()` from the **rversions** package and
tabulate the following

- year 
- month with label
- weekday with label
- hour
- and quarter

## Create, Update & Verify {#createupdate}

```{r cline_youtube_verify, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "agGDD-xbtDo")
```

In the second section, we learnt to create date-time objects using `as.Date()`, 
`as.POSIXct()` etc. In this section, we will explore a few other functions that 
will allow us to do the same

- `make_date()`
- `make_datetime()`

### Create

To create date without time components, use `make_date()` and specify the 
following:

- year
- month
- date

We need to specify all the components in numbers i.e. we cannot use `Dec` or 
`December` for the month. It has to be `12`.

```{r make_date}
make_date(year  = 2019,
          month = 12,
          day   = 12)
```

When you need to include time components, use `make_datetime()`.

```{r make_datetime}
make_datetime(year  = 2019,
              month = 12,
              day   = 12,
              hour  = 08,
              min   = 05,
              sec   = 03,
              tz    = "UTC")
```

### Update

Let us look at another scenario. You have a date-time object and want to change 
one of its components i.e. any of the following

- year
- month
- date

Instead of creating another date-time object, you can change any of the 
components using `update()`. In the below example, we will start with the date 
of release of R version 3.6.1 and using `update()`, we will change it to
`2019-12-12`.

```{r update}
prev_release <- ymd("2019-07-05")
prev_release %>% 
  update(year  = 2019,
         month = 12,
         mday  = 12)
```

### Date Sequence

So far we have created a single date-time instance. How about creating a 
sequence of dates? We can do that using `seq.Date()`. We need to specify the 
from date as the bare minimum input. If the end date is not specified, it will 
create the sequence uptil the current date.

The interval of the sequence can be specified in any of the following units:

- day
- week
- month
- quarter
- year

We can add the following to the interval units

- integer
- `+` / `-` (increment or decrement)

Using the integer, we can specify multiples of the units mentioned and using the 
sign, we can specify whether to increment or decrement.

The below table displays the main arguments used in `seq.Date()`:

```{r table_seq_date, echo=FALSE}
cname   <- c("`from`", "`by`", "`to`", "`length.out`", "`along.with`")
descrip <- c("Starting date of the sequence", "End date of the sequence", 
             "Date increment of the sequence", "Length of the sequence",
             "Use length of this value as length of sequence")
data.frame(Function = cname, Description = descrip) %>% 
  kable() %>% 
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive")
  )
```

In the first example, we will create a sequence of dates from `2010-01-01` to 
`2019-12-31`. The unit of increment should be a year i.e. the difference
between the dates in the sequence should be 1 year, specified using the `by` 
argument.

```{r seq_date_1}
seq.Date(from = as.Date("2010-01-01"), to = as.Date("2019-12-31"), by = "year")
```

In the next example, we change the unit of increment to a quarter i.e. the 
difference between the dates in the sequence should be a quarter or 3 months.

```{r seq_date_2}
seq.Date(from = as.Date("2009-12-12"), to = as.Date("2019-12-12"), by = "quarter")
```

We will now create a sequence of dates but instead of specifying the unit of 
increment, we specify the number of dates in the sequence i.e. the length of the
sequence. We do this using the `length.out` argument which specifies the desired
length of the sequence. We want the sequence to have 10 dates including the
start and end date, and hence we supply the value `10` for the `length.out` 
argument.

```{r seq_date_3}
seq.Date(from = as.Date("2010-01-01"), to = as.Date("2019-12-31"), length.out = 10)
```

In all of the previous examples, we have specified both the start and the end
date. Let us look at a few examples where we create a sequence of dates where 
we only specify the start date. In the below example, we want to create a 
sequence of dates starting from `2010-01-01`. The unit of increment should be 1
year i.e. the difference between the dates in the sequence should be 1 year and
the length of the sequence should be `10` i.e. the number of dates including the
start date should be `10`.

```{r seq_date_4}
seq.Date(from = as.Date("2010-01-01"), by = "year", length.out = 10)
```

The unit of increment can include multiples and `+/-` sign i.e. it can be an
unit of increment or decrement. In the next example, we can increment the dates
in the sequence by `2` i.e. the difference between the dates should be `2`
instead of `1`. This is achieved by specifying the unit of increment (multiple)
first followed by a space and then the unit. In our example, it is `2 year`. As
you can see, the sequence now goes all the way till `2028` and the gap between 
the dates is 2 years.

```{r seq_date_5}
seq.Date(from = as.Date("2010-01-01"), by = "2 year", length.out = 10)
```

Let us say instead of increment we want to decrement the dates i.e. the sequence 
of dates will go backwards as shown in the next example. We achieve this by 
using the `-` sign along with the unit of decrement. The sequence of dates in 
next example starts from `2010` and goes back upto `1992` and the difference 
between the dates in 2 years.

```{r seq_date_6}
seq.Date(from = as.Date("2010-01-01"), by = "-2 year", length.out = 10)
```

In the last example, we will explore the `along.with` argument. Here we have 
supplied a vector which is a sequence of numbers from 1 to 10. The length of 
this vector is 10 and the same length is used as the length of the sequence i.e. 
the length of value supplied to `along.with` is also the length of the sequence.

```{r seq_date_7}
seq.Date(from = as.Date("2010-01-01"), by = "-2 year", along.with = 1:10)
```

### Verify Type

How do you check if the data is a date-time object? You can do that using any 
of the following from the lubridate package.

- `is.Date()`
- `is.POSIXct()`
- `is.POSIXlt()`

```{r check_type}
is.Date(release_date)
is.POSIXct(release_date)
is.POSIXlt(release_date)
```

### Your Turn

- R 2.0.0 was released on `2004-10-04 14:24:38`. Create this date using both
`make_date()` and `make_datetime()`

- R 3.0.0 was released on `2013-04-03 07:12:36`. Update the date created in the
previous step to the above using `update()`

## Intervals, Duration & Period 

```{r cline_youtube_interval, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "8LW7vSx4cew")
```

In this section, we will learn about 

- intervals
- duration
- and period

### Interval {#intervals}

An interval is a timespan defined by two date-times. Let us represent the length
of the course using `interval`. 

<br>

```{r img_course_interval, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/course_interval.png")
```

<br>

```{r lub10}
course_start    <- as_date('2017-04-12')
course_end      <- as_date('2017-04-21')
interval(course_start, course_end)
```

If you observe carefully, the interval is represented by the course start and
end dates. We will learn how to use intervals in the case study.

#### Overlapping Intervals

Let us say you are planning a vacation and want to check if the vacation
dates overlap with the course dates. You can do this by:

- creating vacation and course intervals
- use `int_overlaps()` to check if two intervals overlap. It returns `TRUE`
if the intervals overlap else `FALSE`.

Let us use the vacation start and end dates to create `vacation_interval`
and then check if it overlaps with `course_interval`. 

<br>

```{r img_intervals_overlap, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/interval_overlap.png")
```

<br>

```{r lub60, collapse = TRUE}
vacation_start    <- as_date('2017-04-19')
vacation_end      <- as_date('2017-04-25')
course_interval   <- interval(course_start, course_end)
vacation_interval <- interval(vacation_start, vacation_end)
int_overlaps(course_interval, vacation_interval)
```

#### How many invoices were settled within due date?

Let us use intervals to count the number of invoices that were settled within
the due date. To do this, we will:

- create an interval for the invoice and due date
- create a new column `due_next` by incrementing the due date by 1 day
- another interval for `due_next` and the payment date
- if the intervals overlap, the payment was made within the due date 

```{r lub7}
transact %>%
  mutate(
    inv_due_interval = interval(Invoice, Due),
    due_next         = Due + days(1),
    due_pay_interval = interval(due_next, Payment),
    overlaps         = int_overlaps(inv_due_interval, due_pay_interval)
  ) %>%
  select(Invoice, Due, Payment, overlaps)
```

Below we show another method to count the number of invoices paid within the
due date. Instead of using `days` to change the due date, we use `int_shift`
to shift it by 1 day.

```{r lub12}
transact %>%
  mutate(
    inv_due_interval = interval(Invoice, Due),
    due_pay_interval = interval(Due, Payment),  
    due_pay_next     = int_shift(due_pay_interval, by = days(1)),
    overlaps         = int_overlaps(inv_due_interval, due_pay_next)
  ) %>%
  select(Invoice, Due, Payment, overlaps)
```

You might be thinking why we incremented the due date by a day before creating
the interval between the due day and the payment day. If we do not increment, 
both the intervals will share a common date i.e. the due date and they will
always overlap as shown below:

```{r lub7a}
transact %>%
  mutate(
    inv_due_interval = interval(Invoice, Due),
    due_pay_interval = interval(Due, Payment),
    overlaps         = int_overlaps(inv_due_interval, due_pay_interval)
  ) %>%
  select(Invoice, Due, Payment, overlaps)
```

#### Shift Interval

Intervals can be shifted too. In the below example, we shift the course 
interval by:

- 1 day
- 3 weeks
- 1 year 

<br>

```{r img_shift_interval, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/shift_interval.png")
```

<br>

```{r lab50, collapse = TRUE}
course_interval <- interval(course_start, course_end)

# shift course_interval by 1 day 
int_shift(course_interval, by = days(1))

# shift course_interval by 3 weeks
int_shift(course_interval, by = weeks(3))

# shift course_interval by 1 year
int_shift(course_interval, by = years(1))
```

### Within

Let us assume that we have to attend a conference in April 2017. Does it 
clash with the course? We can answer this using `%within%` which will
return `TRUE` if a date falls within an interval.

<br>

```{r img_within, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/within.png")
```

<br>

```{r lub30, collapse = TRUE}
conference <- as_date('2017-04-15')
conference %within% course_interval
```

#### How many invoices were settled within due date?

Let us use `%within%` to count the number of invoices that were settled within 
the due date. We will do this by:

- creating an interval for the invoice and due date
- check if the payment date falls within the above interval

```{r lub13}
transact %>%
  mutate(
    inv_due_interval = interval(Invoice, Due),
    overlaps         = Payment %within% inv_due_interval
  ) %>%
  select(Due, Payment, overlaps)
```

### Duration

Duration is timespan measured in seconds. To create a duration object, use
`duration()`. The timespan can be anything from seconds to years but it will be
represented as seconds. Let us begin by creating a duration object where the timespan is in seconds.

```{r duration_1}
duration(50, "seconds")
```

Another way to specify the above timespan is shown below:

```{r duration_2}
duration(second = 50)
```

As you can see, the output is same in both the cases. Let us increase the timespan to 60 seconds and see what happens.

```{r duration_3}
duration(second = 60)
```

Although the timespan is primarily measured in seconds, it also shows `~1 minutes` in the brackets. As the length of the timespan increases i.e. the number becomes large, it is represented using larger units such as hours and days. In the below examples, as the number of seconds increases, you can observe larger units being used to represent the timespan.


```{r duration_4}
# minutes
duration(minute = 50)
duration(minute = 60)

# hours
duration(hour = 23)
duration(hour = 24)
```

The following helper functions can be used to create duration objects as well.

```{r duration_5}
# default
dseconds()
dminutes()

# seconds
duration(second = 59)
dseconds(59)

# minutes
duration(minute = 50)
dminutes(50)

# hours
duration(hour = 36)
dhours(36)

# weeks
duration(week = 56)
dweeks(56)
```

Let us use the above helper functions to get the course length in different units.

```{r img_convert, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/convert.png")
```

<br>

```{r lub11, collapse = TRUE}
# course length in seconds 
course_interval / dseconds()

# course length in minutes
course_interval / dminutes()

# course length in hours
course_interval / dhours()

# course length in weeks
course_interval / dweeks()

# course length in years
course_interval / dyears()
```

### Period

A `period` is a timespan defined in units such as years, months, and days. In
the below examples, we use `period()` to represent timespan using different
units.

```{r period_examples}
# second
period(5, "second")
period(second = 5)

# minute & second
period(c(3, 5), c("minute", "second"))
period(minute = 3, second = 5)

# hour, minte & second
period(c(1, 3, 5), c("hour", "minute", "second"))
period(hour = 1, minute = 3, second = 5)

# day, hour, minute & second
period(c(3, 1, 3, 5), c("day", "hour", "minute", "second"))
period(day = 3, hour = 1, minute = 3, second = 5)
```

<br>

```{r img_as_period, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/as_period.png")
```

<br>

Let us get the course length in different units using `as.period()`.

```{r lub17, collapse = TRUE}
# course length in second
as.period(course_interval, unit = "seconds")

# course length in hours and minutes
as.period(course_interval, unit = "minutes")

# course length in hours, minutes and seconds
as.period(course_interval, unit = "hours")
```


`time_length()` computes the exact length of a timespan i.e. `duration`, `interval` or `period`. Let us use `time_length()` to compute the length of the
course in different units.

<br>

```{r img_time_length, echo=FALSE, out.width="80%", fig.align="center"}
knitr::include_graphics("/img/time_length.png")
```

<br>

```{r lub16, collapse = TRUE}
# course length in seconds
time_length(course_interval, unit = "seconds")

# course length in minutes
time_length(course_interval, unit = "minutes")

# course length in hours
time_length(course_interval, unit = "hours")
```

## Round & Rollback  {#others}

```{r cline_youtube_others, eval=TRUE, echo=FALSE}
blogdown::shortcode("youtube", "ZI1s6XQgCbo")
```

In this section, we will learn to round date/time to the nearest unit and roll 
back dates. 

### Rounding Dates

We will explore functions for rounding dates

- to the nearest value using `round_dates()`
- down using `floor_date()`
- up using `ceiling_date()`

The unit for rounding can be any of the following:

- second
- minute
- hour
- day
- week
- month
- bimonth
- quarter
- season
- halfyear
- and year

We will look at a few examples using `round_date()` and you will then practice 
using the other two functions.

```{r round_dates}
# minute
round_date(release_date, unit = "minute")
round_date(release_date, unit = "mins")
round_date(release_date, unit = "5 mins")

# hour
round_date(release_date, unit = "hour")

# day
round_date(release_date, unit = "day")
```

### Rollback 

Use `rollback()` if you want to change the date to the last day of the previous 
month or the first day of the month.

```{r rollback_1}
rollback(release_date)
```

To change the date to the first day of the month, use the `roll_to_first` 
argument and set it to `TRUE`.

```{r rollback_2}
rollback(release_date, roll_to_first = TRUE)
```

### Your Turn

- round up R release dates to hours
- round down R release dates to minutes
- rollback R release dates to the beginning of the month

## Readings & References {#references}

- https://lubridate.tidyverse.org/
- https://r4ds.had.co.nz/dates-and-times.html
- https://en.wikipedia.org/wiki/Daylight_saving_time
- https://en.wikipedia.org/wiki/Time_zone
- https://www.worldtimebuddy.com/
- https://en.wikipedia.org/wiki/POSIX

*As the reader of this blog, you are our most important critic and commentator.
We value your opinion and want to know what we are doing right, what we could 
do better, what areas you would like to see us publish in, and any other words
of wisdom you are willing to pass our way.

We welcome your comments. You can email to let us know what you did or did not 
like about our blog as well as what we can do to make our post better.*

**Email: support@rsquaredacademy.com**